cmake_minimum_required(VERSION 3.10)

# This is due to cross-compiling C/C++
set(CMAKE_TRY_COMPILE_TARGET_TYPE "STATIC_LIBRARY")
message("CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")

# if( ${CMAKE_BUILD_TYPE} MATCHES "Unit_Test")
# message(STATUS "-- Adding unit tests from main CMakeLists.txt")
# add_subdirectory(Modules/crossmonitor)
# add_subdirectory(Modules/ex_communication)
# return()
# endif()
project(IOT_GATEWAY C CXX ASM)
message("CMAKE_PROJECT_NAME: ${CMAKE_PROJECT_NAME}")
get_filename_component(CXX_COMPILER_NAME ${CMAKE_CXX_COMPILER} NAME_WE) # Get the base name without extension
message("CXX_COMPILER_NAME: ${CXX_COMPILER_NAME}")

set(CMAKE_C_STANDARD 99)
set(CMAKE_CXX_STANDARD 17)

set(MCU_FAMILY STM32WLxx)
set(MCU_MODEL STM32WLE5xx)
set(MCU_FAMILY_LOWERCASE stm32wlxx)
set(MCU_MODEL_LOWERCASE stm32wle5xx)

set(IOT_GATEWAY_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/..)
set(STARTUP_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/startup_${MCU_MODEL_LOWERCASE}.s)
set(MCU_LINKER_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/STM32WLE5XX_FLASH.ld)

set(EXECUTABLE ${CMAKE_PROJECT_NAME})
# SET(FIRMWARELIB ${IOT_GATEWAY_ROOT_DIR}/asfirmwarelib)
SET(MIDDLEWARES ${IOT_GATEWAY_ROOT_DIR}/Middlewares)

# All source files from project folder
set(PROJECT_SOURCES
    Core/Src/adc.c
    Core/Src/adc_if.c
    Core/Src/main.c
    Core/Src/gpio.c
    Core/Src/app_freertos.c
    Core/Src/filter.c
    Core/Src/rtc.c
    Core/Src/subghz.c
    Core/Src/system.c
    Core/Src/usart.c
    Core/Src/stm32wlxx_it.c
    Core/Src/stm32wlxx_hal_msp.c
    Core/Src/stm32wlxx_hal_timebase_tim.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_rcc.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_rcc_ex.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_flash.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_flash_ex.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_gpio.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_dma.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_dma_ex.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_pwr.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_pwr_ex.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_cortex.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_exti.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_rtc.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_rtc_ex.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_subghz.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_tim.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_tim_ex.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_uart.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_uart_ex.c
    Drivers/BSP/stm32wlxx_nucleo.c
    Drivers/BSP/stm32wlxx_nucleo_radio.c
    Core/Src/system_stm32wlxx.c
    Middlewares/Third_Party/FreeRTOS/Source/croutine.c
    Middlewares/Third_Party/FreeRTOS/Source/event_groups.c
    Middlewares/Third_Party/FreeRTOS/Source/list.c
    Middlewares/Third_Party/FreeRTOS/Source/queue.c
    Middlewares/Third_Party/FreeRTOS/Source/stream_buffer.c
    Middlewares/Third_Party/FreeRTOS/Source/tasks.c
    Middlewares/Third_Party/FreeRTOS/Source/timers.c
    Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2/cmsis_os2.c
    Middlewares/Third_Party/FreeRTOS/Source/portable/MemMang/heap_4.c
    Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM3/port.c
    Core/Src/stm32_lpm_if.c
    Core/Src/sys_app.c
    Core/Src/timer_if.c
    SubGHz_Phy/App/app_subghz_phy.c
    SubGHz_Phy/App/subghz_phy_app.c
    SubGHz_Phy/Target/radio_board_if.c
    Middlewares/Third_Party/SubGHz_Phy/stm32_radio_driver/lr_fhss_mac.c
    Middlewares/Third_Party/SubGHz_Phy/stm32_radio_driver/radio.c
    Middlewares/Third_Party/SubGHz_Phy/stm32_radio_driver/radio_driver.c
    Middlewares/Third_Party/SubGHz_Phy/stm32_radio_driver/radio_fw.c
    Middlewares/Third_Party/SubGHz_Phy/stm32_radio_driver/wl_lr_fhss.c
    Utilities/trace/adv_trace/stm32_adv_trace.c
    Utilities/misc/stm32_mem.c
    Utilities/misc/stm32_systime.c
    Utilities/misc/stm32_tiny_sscanf.c
    Utilities/misc/stm32_tiny_vsnprintf.c
    Utilities/timer/stm32_timer.c
    Utilities/lpm/tiny_lpm/stm32_lpm.c
    Core/Src/usart_if.c
    Core/Src/sys_debug.c
    Core/Src/dma.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_adc.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_hal_adc_ex.c
    Drivers/STM32WLxx_HAL_Driver/Src/stm32wlxx_ll_adc
)

# The self_test.c file requires the number of flash sections before the build process begins.
# This number must be defined in the source code before the build, but its correctness can only
# be confirmed post-build. The values here represent the flash size (in kB) derived from the
# current source code for various CMake build types. If these values become unsynchronized,
# the build will fail due to the script verify_correct_flash_size.py, and these values will
# need to be updated accordingly.
# if(CMAKE_BUILD_TYPE STREQUAL "Debug")
# set(APPLICATION_SIZE_KB 26)
# elseif(CMAKE_BUILD_TYPE STREQUAL "Release")
# set(APPLICATION_SIZE_KB 24)
# elseif(CMAKE_BUILD_TYPE STREQUAL "MinSizeRel")
# set(APPLICATION_SIZE_KB 24)
# elseif(CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
# set(APPLICATION_SIZE_KB 24)
# endif()

# set_source_files_properties(Core/Src/self_test.c PROPERTIES COMPILE_DEFINITIONS
# "APPLICATION_SIZE_SECTIONS=${APPLICATION_SIZE_KB}U"
# )

# add_subdirectory(Modules/crossmonitor)
# add_subdirectory(Modules/ex_communication)

# All other source files
# set(LIBRARY_SOURCES
# ${MIDDLEWARES}/STM32_Safety_STL/G0/Src/stl_user_param_template.c
# ${MIDDLEWARES}/STM32_Safety_STL/G0/Src/stl_util.c
# ${FIRMWARELIB}/encoding/checksum.c
# )

# Add subdirectory with gtest tests here before potentially returning early if arm-none-eabi-g++ is not the
# selected compiler (which will be the case if Mono Unit Tests is the selected kit)
# add_subdirectory(test/google_test)

# If incompatible compiler is selected when trying to build Mono_SFCPU target, create dummy executable
# for Mono_SFCPU with error message and return early
if(NOT CXX_COMPILER_NAME STREQUAL "arm-none-eabi-g++")
    add_custom_target(${EXECUTABLE}
        COMMAND ${CMAKE_COMMAND} -E echo "Error: Unsupported compiler detected(${CXX_COMPILER_NAME}). Use correct compiler(arm-none-eabi-g++) by selecting the CMake kit: Mono_SFCPU"
    )
    return()
endif()

add_executable(${EXECUTABLE}
    ${STARTUP_SCRIPT}
    ${PROJECT_SOURCES}
)

target_compile_definitions(${EXECUTABLE} PRIVATE
    ${MCU_MODEL}
    USE_HAL_DRIVER
)

target_include_directories(${EXECUTABLE}
    PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/Core/Inc
    ${CMAKE_CURRENT_SOURCE_DIR}/Drivers/STM32WLxx_HAL_Driver/Inc
    ${CMAKE_CURRENT_SOURCE_DIR}/Drivers/STM32WLxx_HAL_Driver/Inc/Legacy
    ${CMAKE_CURRENT_SOURCE_DIR}/Middlewares/Third_Party/FreeRTOS/Source/include
    ${CMAKE_CURRENT_SOURCE_DIR}/Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2
    ${CMAKE_CURRENT_SOURCE_DIR}/Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM3
    ${CMAKE_CURRENT_SOURCE_DIR}/Drivers/CMSIS/Device/ST/STM32WLxx/Include
    ${CMAKE_CURRENT_SOURCE_DIR}/Drivers/BSP
    ${CMAKE_CURRENT_SOURCE_DIR}/Drivers/CMSIS/Include
    ${CMAKE_CURRENT_SOURCE_DIR}/SubGHz_Phy/App
    ${CMAKE_CURRENT_SOURCE_DIR}/SubGHz_Phy/Target
    ${CMAKE_CURRENT_SOURCE_DIR}/Utilities/trace/adv_trace
    ${CMAKE_CURRENT_SOURCE_DIR}/Utilities/misc
    ${CMAKE_CURRENT_SOURCE_DIR}/Utilities/timer
    ${CMAKE_CURRENT_SOURCE_DIR}/Utilities/lpm/tiny_lpm
    ${CMAKE_CURRENT_SOURCE_DIR}/Middlewares/Third_Party/SubGHz_Phy
    ${CMAKE_CURRENT_SOURCE_DIR}/Middlewares/Third_Party/SubGHz_Phy/stm32_radio_driv
)

target_compile_options(${EXECUTABLE} PRIVATE
    -Wall # Enables most warning messages
    -Wextra # Enables some extra warning messages
    -Wpedantic # Generate warnings for non-standard or potentially problematic code constructs that does not follow C standard

    # -Werror # Treat all compiler warnings as errors (enable when code compiles without warnings)
)

# add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/Drivers)

# target_include_directories(stm32wlxx_hal_driver PRIVATE
# ${CMAKE_CURRENT_SOURCE_DIR}/Core/Inc
# )

# target_include_directories(cmsis_dsp PRIVATE
# ${CMAKE_CURRENT_SOURCE_DIR}/Core/Inc
# )

# target_compile_definitions(stm32wlxx_hal_driver PUBLIC
# ${MCU_MODEL}
# USE_HAL_DRIVER
# )
target_link_libraries(${EXECUTABLE} stm32wlxx_hal_driver)

# target_link_libraries(${EXECUTABLE} crossmonitor)
# target_link_libraries(${EXECUTABLE} ex_communication)

# add_compile_definitions(WATCHDOG_DISABLED)
if(CMAKE_BUILD_TYPE STREQUAL "Debug" OR CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
    add_compile_definitions(USERDEBUG)
endif()

target_link_options(${EXECUTABLE} PRIVATE
    -T${MCU_LINKER_SCRIPT} # Linker script to be used during the linking stage of compilation
    -Wl,-Map=${CMAKE_PROJECT_NAME}.map # Generates a memory map file during the linking stage
    -Wl,--start-group # Start searching for unresolved symbols
    -lc # Links the C standard library
    -lm # Links the math library
    -Wl,--end-group # Stop searching for unresolved symbols
    -Wl,--print-memory-usage # Print memory usage statistics after linking
    -lnosys
)

add_custom_command(TARGET ${EXECUTABLE} POST_BUILD
    COMMAND ${CMAKE_SIZE} $<TARGET_FILE:${EXECUTABLE}>
)

# After the build, the size sections are outputted to a text file.
# The Python script verify_correct_flash_size.py is then run to check if the flash size is correct.
# add_custom_command(TARGET ${EXECUTABLE} POST_BUILD
# COMMAND ${CMAKE_SIZE} $<TARGET_FILE:${EXECUTABLE}> > size_output.txt
# COMMAND python ${CMAKE_SOURCE_DIR}/scripts/verify_correct_flash_size.py ${APPLICATION_SIZE_KB}
# )
add_custom_command(TARGET ${EXECUTABLE} POST_BUILD
    COMMAND ${CMAKE_OBJCOPY} -O ihex $<TARGET_FILE:${EXECUTABLE}>
    ${EXECUTABLE}.hex
    COMMAND ${CMAKE_OBJCOPY} -O binary $<TARGET_FILE:${EXECUTABLE}>
    ${EXECUTABLE}.bin
)

# set(MINIMUM_STM32_PROGRAMMER_CLI_VERSION "2.15.0")
# include(${IOT_GATEWAY_ROOT_DIR}/cmake/FindSTM32ProgrammerCLI.cmake)

# add_custom_command(TARGET ${EXECUTABLE} POST_BUILD
# COMMAND echo "Injecting CRC to .elf, .hex and .bin with ${STM32_PROGRAMMER_CLI_EXECUTABLE}"
# COMMAND ${STM32_PROGRAMMER_CLI_EXECUTABLE} -sl ${EXECUTABLE}.hex 0x08000000 0x08010000 0x400
# COMMAND ${STM32_PROGRAMMER_CLI_EXECUTABLE} -sl ${EXECUTABLE}.bin 0x08000000 0x08010000 0x400
# COMMAND ${STM32_PROGRAMMER_CLI_EXECUTABLE} -sl ${EXECUTABLE}.elf 0x08000000 0x08010000 0x400
# COMMAND echo "Injecting CRC finished"
# )
